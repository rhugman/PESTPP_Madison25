[
  {
    "objectID": "notebooks/simple_LP_example.html",
    "href": "notebooks/simple_LP_example.html",
    "title": "Simple Linear Programming Example",
    "section": "",
    "text": "In this notebook we are going to dig into the basics of optimization underpinning PESTPP-OPT (and to an extent, PESTPP-MOU) through a very simple linear programming example, reproduced from https://realpython.com/linear-programming-python/\nCode\nimport os\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning) \n\nfrom scipy.optimize import linprog",
    "crumbs": [
      "Home",
      "Simple Linear Programming Example"
    ]
  },
  {
    "objectID": "notebooks/simple_LP_example.html#now-lets-set-up-and-solve-the-optimization-problem.",
    "href": "notebooks/simple_LP_example.html#now-lets-set-up-and-solve-the-optimization-problem.",
    "title": "Simple Linear Programming Example",
    "section": "Now, let’s set up and solve the optimization problem.",
    "text": "Now, let’s set up and solve the optimization problem.\n\n\nCode\nobj = [-1, -2]\n#wait why does z= x+2y have coefficients of -1 and -2 instead of 1 and 2? \n#because scipy linprog assumes minimization. to \"maximize,\" we flip them to negative\n\nlhs_ineq = [[ 2,  1],  # Red constraint left side\n             [-4,  5],  # Blue constraint left side\n             [ 1, -2]]  # Yellow constraint left side \n#(again, note that coefficient signs are flipped because it's a greater than constraint rather than less than)\n\nrhs_ineq = [20,  # Red constraint right side\n            10,  # Blue constraint right side\n            -2]  # Yellow constraint right side\n\n\n\n\nCode\nbnd = [(0, float(\"inf\")),  # Bounds of x\n        (0, float(\"inf\"))]  # Bounds of y\n\n\n\n\nCode\nopt = linprog(c=obj, A_ub=lhs_ineq, b_ub=rhs_ineq,\n               bounds=bnd, method=\"simplex\")\n\n\nWe can print the objective function value.\n\n\nCode\nopt.fun \n\n\nAnd check to see if an optimal solution (value of x and y) was found\n\n\nCode\nopt.success \n\n\nLet’s print out the decision variable values for that optimal solution\n\n\nCode\nopt.x \n\n\nAnd we can visualize those decision variable values on our plot.\n\n\nCode\nx = np.linspace(0,1000)\ny = 20 - 2*x\nplt.fill_between(x, y,1000, color='red', alpha=0.3)\n\nx = np.linspace(0,1000)\ny = (10 + 4*x)/5\nplt.fill_between(x, y,1000, color='blue', alpha=0.3)\n\nx = np.linspace(0,1000)\ny = (-2 + x)/2\nplt.fill_between(x, y, color='yellow', alpha=0.3)\n\nplt.xlim(0,10)\nplt.ylim(0,10)\n\nplt.scatter(opt.x[0],opt.x[1],c='black')\n\n\nNotice that the solution is in the feasible region but right at the boundary of two of the constraints. This is where optimization departs from parameter estimation, as it is normal and even optimal for parameters to hit their bounds.",
    "crumbs": [
      "Home",
      "Simple Linear Programming Example"
    ]
  },
  {
    "objectID": "notebooks/simple_LP_example.html#what-if-we-further-bounded-the-decision-variables-x-and-y",
    "href": "notebooks/simple_LP_example.html#what-if-we-further-bounded-the-decision-variables-x-and-y",
    "title": "Simple Linear Programming Example",
    "section": "What if we further bounded the decision variables x and y?",
    "text": "What if we further bounded the decision variables x and y?\n\n\nCode\nbnd = [(0, 3),  # Bounds of decision variable x\n        (0, 4)]  # Bounds of decision variable y\n\n\n\n\nCode\nopt = linprog(c=obj, A_ub=lhs_ineq, b_ub=rhs_ineq,\n               bounds=bnd, method=\"simplex\")\n\n\n\n\nCode\nx = np.linspace(0,1000)\ny = 20 - 2*x\nplt.fill_between(x, y,1000, color='red', alpha=0.3)\n\nx = np.linspace(0,1000)\ny = (10 + 4*x)/5\nplt.fill_between(x, y,1000, color='blue', alpha=0.3)\n\nx = np.linspace(0,1000)\ny = (-2 + x)/2\nplt.fill_between(x, y, color='yellow', alpha=0.3)\n\nplt.xlim(0,10)\nplt.ylim(0,10)\n\nplt.axvline(bnd[0][1],ls='--',c='black')\nplt.axhline(bnd[1][1],ls='--',c='black')\n\nplt.scatter(opt.x[0],opt.x[1],c='black')\n\n\nNow, the optimal solution is entirely constrained by the bounded values of the decision variables. Thus, in linear optimization, the constraints are key and decision variable bounds should be carefully designed. For example, for maximizing pumping subject to the constraint of not capturing too much streamflow, we still want to set bounds on our pumping wells based on actual pump capacity and yield.",
    "crumbs": [
      "Home",
      "Simple Linear Programming Example"
    ]
  },
  {
    "objectID": "notebooks/simple_pstfrom.html",
    "href": "notebooks/simple_pstfrom.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All Code\n\n\n\n\n\n\nCode\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pyemu\nimport flopy\nimport platform\nfrom pathlib import Path\nimport shutil\nimport pandas as pd\n\n\n\n\nCode\norg_ws = Path('../MV_Model_Files/')\nnew_ws = 'simple_ies'\nif \"macos\" in platform.platform().lower() or \"darwin\" in platform.platform().lower():\n    exe_dir = Path('../bin/mac/')\nelif \"linux\" in platform.platform().lower():\n    exe_dir = Path('../bin/linux/')\nelse:\n    exe_dir = Path('../bin/windows/')\n\n\n\n\nCode\nif os.path.exists(new_ws):\n    shutil.rmtree(new_ws)\nshutil.copytree(org_ws, new_ws)\nfor f in os.listdir(exe_dir):\n    shutil.copy2(os.path.join(exe_dir,f),os.path.join(new_ws,f))\n\n\n\n\nCode\nsim = flopy.mf6.MFSimulation.load(sim_ws = new_ws)\n\n\n\n\nCode\npyemu.os_utils.run('mf6',cwd=new_ws)\n\n\n\n\nCode\nfor f in [\"k_aq.ref\",\"k_clay.ref\"]:\n    arr = np.loadtxt(os.path.join(new_ws,f))\n    arr[:,:] = arr.mean()\n    np.savetxt(os.path.join(new_ws,f),arr,fmt=\"%15.6E\")\n\n\n\n\nCode\npyemu.os_utils.run('mf6',cwd=new_ws)\n\n\n\n\nCode\n#need a spatial reference to use pilot points. this means xoff, yoff, rotation, epsg\nm=sim.get_model()\nm.modelgrid\n\n\n\n\nCode\npf = pyemu.utils.PstFrom(original_d=new_ws,\n                         new_d='template',\n                         remove_existing=True,\n                         start_datetime=\"1-1-2025\",\n                         spatial_reference=m.modelgrid)\n\n\n\n\nCode\n?pf.add_parameters\n\n\n\n\nCode\nk_pars = [f for f in os.listdir(new_ws) if 'k_' in f and f.endswith('.ref')]\nk_pars\nfor f in k_pars:\n    pf.add_parameters(f,par_type='constant',upper_bound=20,lower_bound=0.05,pargp=\"cn-\"+f,par_name_base=\"cn-\"+f)\n\n\n\n\nCode\n#for pilot points, we first need to build a variogram, which describes the underlying spatial correlation structure of the variable\npp_v = pyemu.geostats.ExpVario(contribution=1.0, a=5000) #rule of thumb is that range should be atleast 2x pp spacing (delr= 500\npp_gs = pyemu.geostats.GeoStruct(variograms=pp_v,transform='log')\nax=pp_gs.plot()\nax.axvline(x=500*5*5)\n\n\n\n\nCode\nfor f in k_pars:\n    base = f.split('.')[0]\n    pf.add_parameters(f,par_type='pilotpoint',upper_bound=20,lower_bound=0.05,pp_space=3,geostruct=pp_gs,pargp=\"pp-\"+f,par_name_base=\"pp-\"+f)\n\n\n\n\nCode\n?pf.add_observations\n\n\n\n\nCode\n[f for f in os.listdir(new_ws) if f.endswith('.csv')]\n\n\n\n\nCode\nobs_csvs = [f for f in os.listdir(new_ws) if f.endswith('.csv')]\nfor f in obs_csvs:\n    df = pd.read_csv(os.path.join(new_ws,f))\n    pf.add_observations(f,index_cols='time',use_cols=df.columns.tolist()[1:])\n\n\n\n\nCode\nfor f in k_pars:\n    pf.add_observations(f)\n\n\n\n\nCode\npf.mod_sys_cmds.append('mf6')\n\n\n\n\nCode\n?pf.draw\n\n\n\n\nCode\npst = pf.build_pst(filename=os.path.join(pf.new_d,'at.pst'),version=2)\n\n\n\n\nCode\n# add in the recharge parameter\nr = pst.add_parameters('./simple_ies/at.rch.tpl', pst_path='.')\npars = pst.parameter_data\npars.loc['rch','parval1'] = r.loc['rch'].parval1\npars.loc['rch','parlbnd'] = pars.loc['rch'].parval1 * .8\npars.loc['rch','parubnd'] = pars.loc['rch'].parval1 * 1.2\npars.loc['rch','pargp'] = 'recharge'\n\npars.loc['rch']\n\n\n\n\nCode\nrb = pst.add_parameters('./simple_ies/riv.ref.tpl', pst_path='.')\nrb\n\n\n\n\nCode\n# and the riverbed conductance\npars = pst.parameter_data\npars.loc['rv1','parval1'] = rb.loc['rv1'].parval1\npars.loc['rv1','parlbnd'] = pars.loc['rv1'].parval1 * .1\npars.loc['rv1','parubnd'] = pars.loc['rv1'].parval1 * 10.0\npars.loc['rv1','pargp'] = 'riverbed'\n\npars.loc['rv1']\n\n\n\n\nCode\npst.write(os.path.join(pf.new_d,'at.pst'),version=2)\n\n\n\n\nCode\n#draw prior ensemble that accounts for PP spatial correlation (this is for later for when we want to use iES)\npe = pf.draw(num_reals=300)\npe.enforce()\npe.to_csv(os.path.join(pf.new_d,'prior.csv'))\n\n\n\n\n\nCode\npst = pyemu.Pst(filename=os.path.join(pf.new_d,'at.pst'))\n\n\n\n\nCode\npst.pestpp_options[\"ies_par_en\"] = \"prior.csv\"\nobs = pst.observation_data\nobs\n\n\n\n\nCode\npyemu.os_utils.run('pestpp-ies at.pst',cwd='template')\n\n\n\n\nCode\npst.set_res(os.path.join(pf.new_d,\"at.base.rei\"))\n\n\n\n\nCode\npst.phi\n\n\n\n\nCode\nassert pst.phi &lt; 1e-6\n\n\n\n\nCode\n#zero everything out for starters\nobs.weight = 0\n\n\n\n\nCode\n#we need to tell PEST what are the observed values and their weights, to calc the objective function\ntruth = pd.read_csv(os.path.join(new_ws,'obsvalues.dat'),sep=r'\\s+')\ntruth\n\n\n\n\nCode\nobs[\"standard_deviation\"] = np.nan\nfor i,stuff in truth.iterrows():\n    if \"headgroup\" in stuff.obgnme or \"headdiffgroup\" in stuff.obgnme or \"riv\" in stuff.obgnme:\n        obs.loc[obs.obsnme.str.contains(stuff.obsnme),'obsval'] = stuff.obsval\n        obs.loc[obs.obsnme.str.contains(stuff.obsnme),'weight'] = stuff.weight\n        obs.loc[obs.obsnme.str.contains(stuff.obsnme),'obgnme'] = stuff.obgnme\n        if \"headdiff\" in stuff.obgnme:\n            obs.loc[obs.obsnme.str.contains(stuff.obsnme),'standard_deviation'] = np.abs(stuff.obsval) * 0.15 \n        elif \"headgroup\" in stuff.obgnme:\n            obs.loc[obs.obsnme.str.contains(stuff.obsnme),'standard_deviation'] = 1\n        else:\n            obs.loc[obs.obsnme.str.contains(stuff.obsnme),'standard_deviation'] = np.abs(stuff.obsval) * 0.1\n\n\n\n\nCode\nobs.loc[obs.weight&gt;0]\n\n\n\n\nCode\nobs.loc[obs.weight&gt;0,:].describe()\n\n\n\n\nCode\npst.observation_data = obs\npst.write(os.path.join(pf.new_d,'at.pst'),version=2)\n\n\n\n\nCode\npyemu.os_utils.run('pestpp-ies at.pst',cwd='template')\n\n\n\n\nCode\nphi= pst.phi\nphi\n\n\n\n\nCode\npst.parameter_data.loc[:,\"parval1\"] = pe.loc[pe.index[0],pst.par_names].values\n\n\n\n\nCode\npst.parameter_data.head()\n\n\n\n\nCode\npst.write(os.path.join(pf.new_d,\"test.pst\"),version=2)\npyemu.os_utils.run(\"pestpp-ies test.pst\",cwd=pf.new_d)\n\n\n\n\nCode\npst.set_res(os.path.join(pf.new_d,\"test.base.rei\"))\npst.phi\n\n\n\n\nCode\nkobs = obs.loc[obs.obsnme.str.contains(\"k_aq\"),:].copy()\nkobs['i'] = kobs.i.astype(int)\nkobs['j'] = kobs.j.astype(int)\n\n\n\n\nCode\narr = np.zeros((kobs.i.max()+1,kobs.j.max()+1))\narr[kobs.i,kobs.j] = np.log10(pst.res.loc[kobs.obsnme,\"modelled\"].values)\ncb = plt.imshow(arr)\nplt.colorbar(cb)\n\n\n\n\nCode\npst = pyemu.Pst(os.path.join(pf.new_d,\"at.pst\"))\npst.control_data.noptmax = -2\npst.write(os.path.join(pf.new_d,\"at.pst\"),version=2)\npyemu.os_utils.run(\"pestpp-ies at.pst\",cwd=pf.new_d)\n\n\n\n\nCode\npst.set_res(os.path.join(pf.new_d,\"at.base.rei\"))\npst.phi\n\n\n\n\nCode\narr = np.zeros((kobs.i.max()+1,kobs.j.max()+1))\narr[kobs.i,kobs.j] = np.log10(pst.res.loc[kobs.obsnme,\"modelled\"].values)\ncb = plt.imshow(arr)\nplt.colorbar(cb)",
    "crumbs": [
      "Home",
      "simple_pstfrom.html"
    ]
  },
  {
    "objectID": "notebooks/simple_ies.html",
    "href": "notebooks/simple_ies.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All Code\n\n\n\n\n\n\nCode\nimport os\nimport sys\nsys.path.insert(0,\"..\")\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pyemu\nprint(pyemu.__file__)\nimport flopy\nimport platform\nfrom pathlib import Path\nimport shutil\nimport pandas as pd\n\n\n\n\nCode\nt_d = \"template\"\nif not os.path.exists(t_d):\n    raise Exception(\"need to run simple_pstfrom notebook\")\n\n\n\n\nCode\npst = pyemu.Pst(os.path.join(t_d,\"at.pst\"))\npst.npar,pst.nobs\n\n\n\n\nCode\npst.pestpp_options\n\n\n\n\nCode\nif \"ies_par_en\" not in pst.pestpp_options:\n    raise Exception(\"prior par ensemble not found\")\n\n\n\n\nCode\npst.pestpp_options = {\"ies_par_en\":pst.pestpp_options[\"ies_par_en\"]}\npst.pestpp_options[\"ies_num_reals\"] = 50\npst.pestpp_options[\"ies_bad_phi_sigma\"] = 1.75\npst.pestpp_options\n\n\n\n\nCode\npst.control_data.noptmax = 5\n\n\n\n\nCode\npst.obs_groups\n\n\n\n\nCode\nweighted_groups = pst.nnz_obs_groups\nweighted_groups.sort()\nweighted_groups\n\n\n\n\nCode\nwts = [1e-30,.8,.2]\n\n\n\n\nCode\nwith open(f'{t_d}/phi_factors.csv', 'w') as ofp:\n    [ofp.write(f'{g},{w}\\n') for g,w in zip(weighted_groups,wts)]\n\n\n\n\nCode\npst.pestpp_options['ies_phi_factor_file']='phi_factors.csv'\n\n\n\n\nCode\npst.write(os.path.join(t_d,\"at.pst\"),version=2)\n\n\n\n\nCode\nm_d = \"master_ies_simple\"\n\n\n\n\nCode\npyemu.os_utils.start_workers(t_d,\"pestpp-ies\",\"at.pst\",num_workers=15,master_dir=m_d,worker_root='.')\n\n\n\n\nCode\ndef plot_ies_results(m_d,tag=\"\",noptmax=None):\n    pst = pyemu.Pst(os.path.join(m_d,\"at.pst\"))\n    \n    noise = pst.ies.noise\n    itrs = pst.ies.phiactual.iteration.values\n    if noptmax is None:\n        noptmax = itrs.max()\n    obs = pst.observation_data\n    nzobs = obs.loc[obs.obgnme=='headgroup',:]\n    odict = {n:v for n,v in zip(nzobs.obsnme,nzobs.obsval)}\n    #ptoe = pst.ies.get(\"obsen{0}\".format(noptmax))\n    ptoe = pst.ies.get(\"obsen\",noptmax)\n    proe = pst.ies.obsen0\n    phivals = pst.ies.phimeas.iloc[noptmax,6:]\n    phimean = phivals.mean()\n    phistd = phivals.std()\n    thresh = phimean + (phistd*1.75)\n    keep = phivals[phivals&lt;=thresh].index.values\n    ptoe = ptoe.loc[keep]\n    proe = proe.loc[keep]\n    noise = noise.loc[keep]\n    fig,ax = plt.subplots(1,1,figsize=(6,6))\n    names = obs.loc[obs.obgnme==\"headgroup\",\"obsnme\"].values\n    for oname in names:\n        if \"at.csv\" not in oname:\n            continue\n        ovals = [odict[oname] for _ in range(noise.shape[0])]\n        ax.scatter(ovals,noise[oname],marker='.',c='r',s=100,alpha=0.25)\n        \n        ovals = [odict[oname] for _ in range(ptoe.shape[0])]\n        ax.scatter(ovals,ptoe[oname],marker='.',c='b',alpha=0.5)\n        #ylim = ax.get_ylim()\n        ovals = [odict[oname] for _ in range(proe.shape[0])]\n        ax.scatter(ovals,proe[oname],marker='.',c='0.5',alpha=0.5,zorder=0)\n        #ax.set_ylim(ylim)\n        #ax.set_xlim(ylim)\n    mn,mx = noise.loc[:,names].values.min(),noise.loc[:,names].values.max()\n    ax.plot([mn,mx],[mn,mx],\"k--\",lw=3)\n    ax.set_xlabel(\"obs\")\n    ax.set_ylabel(\"sim\")\n    ax.set_xlim(mn,mx)\n    ax.set_title(tag)\n    \n    _ = ax.set_ylim(mn,mx)\n\n    kobs = obs.loc[obs.obsnme.str.contains(\"k_aq\"),:].copy()\n    kobs['i'] = kobs.i.astype(int)\n    kobs['j'] = kobs.j.astype(int)\n\n    prarr = np.zeros((kobs.i.max()+1,kobs.j.max()+1))\n    prarr[kobs.i,kobs.j] = np.log10(ptoe.loc[:,kobs.obsnme].mean())\n    ptarr = np.zeros((kobs.i.max()+1,kobs.j.max()+1))\n    ptarr[kobs.i,kobs.j] = np.log10(ptoe.loc[\"base\",kobs.obsnme])\n    fig,axes = plt.subplots(1,2,figsize=(8,4))\n    cb = axes[0].imshow(prarr,vmin=ptarr.min())\n    plt.colorbar(cb,ax=axes[0])\n    axes[0].set_title(\"mean \"+tag)\n    \n    cb = axes[1].imshow(ptarr,vmax=prarr.max())\n    plt.colorbar(cb,ax=axes[1])\n    axes[1].set_title(\"min err var \"+tag)\n\n    prarr = np.zeros((kobs.i.max()+1,kobs.j.max()+1))\n    prarr[kobs.i,kobs.j] = np.log10(proe.loc[:,kobs.obsnme].std())\n    ptarr = np.zeros((kobs.i.max()+1,kobs.j.max()+1))\n    ptarr[kobs.i,kobs.j] = np.log10(ptoe.loc[:,kobs.obsnme].std())\n    fig,axes = plt.subplots(1,2,figsize=(8,4))\n    cb = axes[0].imshow(prarr,vmin=ptarr.min())\n    plt.colorbar(cb,ax=axes[0])\n    axes[0].set_title(\"prior stdev \"+tag)\n    cb = axes[1].imshow(ptarr,vmax=prarr.max())\n    plt.colorbar(cb,ax=axes[1])\n    axes[1].set_title(\"posterior stdev \"+tag)\n\n    bobs = obs.loc[obs.oname==\"at.budget.csv\",:]\n    for oname in bobs.obsnme:\n        if \"chd\" not in oname:\n            continue\n        fig,ax = plt.subplots(1,1,figsize=(6,6))\n        ax.hist(proe.loc[:,oname],bins=10,fc=\"0.5\",alpha=0.5,density=True)\n        ax.hist(ptoe.loc[:,oname],bins=10,fc=\"b\",alpha=0.5,density=True)\n        ax.set_title(tag+\" \"+oname)\n        ax.set_yticks([])\n    \n    names = obs.loc[obs.obgnme==\"headgroup\",\"obsnme\"].values\n    noise = pst.ies.noise\n    proe = pst.ies.obsen0\n    ptoe = pst.ies.get(\"obsen{0}\".format(pst.ies.phiactual.iteration.max()))\n    phivals = pst.ies.phimeas.iloc[-1,6:]\n    phimean = phivals.mean()\n    phistd = phivals.std()\n    thresh = phimean + (phistd*1.75)\n    keep = phivals[phivals&lt;=thresh].index.values\n    fig,axes = plt.subplots(2,1,figsize=(10,20))\n    actual,meas = pst.ies.phiactual.iloc[:,6:],pst.ies.phimeas.iloc[:,6:]\n    actual = actual.loc[:,keep]\n    meas = meas.loc[:,keep]\n    \n    axes[0].hist(np.log10(actual.iloc[0,:].values),fc=\"0.5\",alpha=0.5)\n    axes[0].hist(np.log10(actual.iloc[-1,:].values),fc=\"b\",alpha=0.5)\n    axes[0].set_title('log-10 phi w/o noise')\n\n    axes[1].hist(np.log10(meas.iloc[0,:].values),fc=\"0.5\",alpha=0.5)\n    axes[1].hist(np.log10(meas.iloc[-1,:].values),fc=\"b\",alpha=0.5)\n    axes[1].set_title('log-10 phi w/ noise')\n    \n    \n    fig,axes = plt.subplots(2,1,figsize=(10,20))\n    nzobs = nzobs.loc[nzobs.obgnme==\"headgroup\",:]\n    #print(nzobs)\n    ptoe = ptoe.loc[keep,:]\n    nzobs.sort_values(by=\"obsval\",inplace=True)\n    ovals = nzobs.obsval.values\n    for real in ptoe.index:\n        nvals = noise.loc[real,nzobs.obsnme].values   \n        prvals = proe.loc[real,nzobs.obsnme].values\n        ptvals = ptoe.loc[real,nzobs.obsnme].values\n        ax = axes[0]\n        #ax.plot(ovals,nvals,\"r-\",alpha=0.5,lw=0.5)\n        ax.scatter(ovals,nvals,marker='.',alpha=0.2,s=70,c='r')\n        #ax.plot(ovals,prvals,\"0.5\",alpha=0.2,lw=0.3,dashes=(1,1))\n        #ax.plot(ovals,ptvals,\"b\",alpha=0.5,lw=0.5)#,marker='.',ms=5)\n        ax.scatter(ovals,ptvals,marker='.',s=50,c='b')\n        ax = axes[1]\n        ax.plot(ovals,nvals,\"r-\",alpha=0.5,lw=0.5,zorder=0)\n        ax.scatter(ovals,nvals,marker='.',alpha=0.2,s=70,c='r')\n        #ax.plot(ovals,prvals,\"0.5\",alpha=0.2,lw=0.3,dashes=(1,1))\n        #ax.plot(ovals,ptvals,\"b\",alpha=0.5,lw=0.5,zorder=0)#,marker='.',ms=5)\n        ax.scatter(ovals,ptvals,marker='.',s=50,c='b')\n    \n    mn,mx = noise.loc[:,names].values.min(),noise.loc[:,names].values.max()\n    for ax in axes:\n        ax.plot([mn,mx],[mn,mx],\"k--\",lw=3)\n        ax.set_xlabel(\"observed\")\n        ax.set_ylabel(\"simulated\")\n        ax.set_xlim(mn,mx)\n        ax.grid()\n    \n    _ = ax.set_ylim(mn,mx)\n            \n    \n\n\n\n\nCode\nplot_ies_results(m_d)\n\n\n\n\nCode\npst.pestpp_options[\"ies_no_noise\"] = True\npst.write(os.path.join(t_d,\"at.pst\"),version=2)\nm_d = \"master_ies_nonoise\"\npyemu.os_utils.start_workers(t_d,\"pestpp-ies\",\"at.pst\",num_workers=15,master_dir=m_d,worker_root='.')\nplot_ies_results(m_d,\"no noise\")\n\n\n\n\nCode\nobs = pst.observation_data\nhobs = obs.loc[(obs.weight&gt;0) & (obs.obgnme==\"headgroup\"),:]\nhobs.obsnme.tolist()\nassert len(hobs) &gt; 0\nstd = hobs.standard_deviation.max()\nstd\n\n\n\n\nCode\noffsets = np.random.normal(0.0,std,pst.ies.noise.shape[0])\nplt.hist(offsets)\noffsets.shape\n\n\n\n\nCode\novals = obs.loc[pst.nnz_obs_names,\"obsval\"].copy()\nnoise = pst.ies.noise.copy()\nfor i,idx in enumerate(noise.index):\n    noise.loc[idx,hobs.obsnme] = ovals[hobs.obsnme] + offsets[i]\nnoise.to_csv(os.path.join(t_d,\"corrnoise.csv\"))\nprint(noise.loc[:,hobs.obsnme[0]]-ovals.loc[hobs.obsnme[0]])\nprint(noise.loc[:,hobs.obsnme[1]]-ovals.loc[hobs.obsnme[1]])\n\n\n\n\nCode\npst.pestpp_options[\"ies_obs_en\"] = \"corrnoise.csv\"\n\n\n\n\nCode\npst.pestpp_options.pop(\"ies_no_noise\")\n\n\n\n\nCode\npst.write(os.path.join(t_d,\"at.pst\"),version=2)\nm_d = \"master_ies_corrnoise\"\npyemu.os_utils.start_workers(t_d,\"pestpp-ies\",\"at.pst\",num_workers=15,master_dir=m_d,worker_root='.')\nplot_ies_results(m_d,\"corr noise\")",
    "crumbs": [
      "Home",
      "simple_ies.html"
    ]
  }
]